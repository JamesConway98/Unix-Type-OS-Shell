#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h> 
#include <stdbool.h>

void shell_loop();
void getInput();
void tokeniser();
void newCmd(char*);
int checkAlias();
void checkCommands();
int find_command(char []);
void fork_command();
void setpath(char []);
void getpath();
void writeToFile(char*, char*);
void readFile(char*);
void setAlias(int noTokens);
void printAliases();
void unalias(int noTokens);

void listHistory();


int running = 0;
char *tkarray[512];
int numAliases;
	char input[512];
	int nt = 0; //number of tokens

#define historySize 20	// The size of the history array
int cmdcount = 0;		// Keeps keeps track of the number of commands used
char history[historySize][512];	// Pointer to the history of commands used


typedef struct alias{
	char name[15];
	char command[15][15];
	int parameters;
}alias;

struct alias aliases[10];

void main(){
    
    
	char *path = getenv("PATH"); /*saves original path*/
	chdir(getenv("HOME"));
	readFile(".hist_list.txt");// loads history from file
	shell_loop();
	setenv("PATH", path, 1); /*restores orignal path upon exit*/
	printf("%s \n", path);
}


void shell_loop(){

numAliases = 0;

    while(running == 0){
    	printf(":) ");
	getInput();
	tokeniser();
	checkCommands(); //checks the input for list of commands
    }   

}

void setpath(char *dir) {
	char *oldpath = getenv("PATH");
	setenv("PATH", dir, 1);
	char *path = getenv("PATH");
	if (strcmp(dir, path) == 0) {
		printf("%s \n", path);
	}
	else {
		printf("Re-pathing has failed, please try again");
		setenv("PATH", oldpath, 1);
	}
}

void getpath() {
	char *path = getenv("PATH");
	printf("%s \n", path);
}


void getInput(){




	if(fgets(input, 512, stdin) == NULL) { //gets input AND exits if CTRL D is pressed
		printf("\n");
		running = 1;
		return;
	}

	input[strlen(input)-1] = '\0'; //adds null to end of input string

}	

void tokeniser(){

    int aliasFound = 0;
	nt = 0;

		for(int i = 0; i<512; i++){
			tkarray[i] = '\0';

	}
	

	char inputcpy[512];
	char *token;

	strcpy(inputcpy, input); //makes a copy of input



	token = strtok (input, " |><&;\t\n"); //creates the first token
	
	
	if (token == NULL){ //if input is enter key, returns to start of loop
		return;
	}
	
	
	tkarray[nt] = token; //not sure if we still need this line 
	
	//adjusts nt variable for any aliased parameters
	aliasFound = checkAlias();
	if(aliasFound > 0){
	nt = nt + aliasFound;
	}

	while (token != NULL){	//tokenises rest of input
		tkarray[nt] = token;
		token = strtok (NULL, " |><&;\t\n");
		nt++;
	}
	
	//makes sure alias name isn't part of the tkarray (writes over it)
	if(aliasFound > 0){
		for(int i = aliasFound; i < nt; i++){
		tkarray[i] = tkarray[i+1];
		}	
	nt--;
	}
	
	tkarray[nt] = NULL; //sets the last token to null

	if(strcmp(tkarray[0], "!!") == 0 && nt == 1){
		printf("found command\n");
		strcpy(input, history[(cmdcount%historySize)-1]);
		}
	


	else if(strcspn(tkarray[0], "!-") == 1 && nt = 1){ //history invokation. MUST BE ABOVE CHECKCOMMANDS
		
		int histnum = atoi(tkarray[1]);

		printf("%d\n", histnum);
		strcpy(input, history[histnum-1]);
		printf("%s\n", input);
		//tokeniser(input);
		printf("This shouldnt show");
		}

		//else{
			//do a thing as well		
		//}
	else{
		newCmd(inputcpy);	//This adds the input to the history of commands
	}





}
void checkCommands(){
    
	if(strcmp(tkarray[0], "exit") == 0){ //closes the shell
		
		if(nt == 1){
			running = 1;
		}else{
			
			printf("Error: exit command doesn't take parameters\n");		

		}
	}
	

	else if(strcmp(tkarray[0], "cd") == 0){//changes directory
		
		if(nt == 2){
			if (chdir(tkarray[1]) == 0) {
				printf("Changing dir\n");
			}else{
				perror("Error");

			}
		}else if(nt == 1){

			chdir(getenv("HOME"));

		}else{
			printf("Error: cd takes 1 argument\n");	
			
		}
		
	}

	else if (strcmp(tkarray[0], "getpath") == 0){//returns current path
		if (nt == 1) {
			getpath();
		}
		else {
			printf("Error: Getpath does not require any parameters. \n");
		}
	}

	else if (strcmp(tkarray[0], "setpath") == 0){//changes current path
		if (nt ==2) {
			setpath(tkarray[1]);
		}
		else if (nt != 2) {
			printf("Error: incorrect number of parameters. Setpath requires one argument. \n");
		}
	}
	


	
	else if(strcmp(tkarray[0], "history") == 0){ //Command displays history list
		
		if(nt == 1){ //takes one parameter
			listHistory();
		}else{
			
			printf("Error: History command doesn't take parameters\n");		

		}
	}
	
    else if(strcmp(tkarray[0], "alias") == 0){
	
		if(nt >= 3){//sets new alias
			if(numAliases <= 10){
		 setAlias(nt);
			numAliases++;}
			else printf("Error: Maximum number of aliases has been reached. unable to add alias.\n");
			}

		else if(nt == 1){//prints list of aliases
		printAliases();}
		
		else{ 
			printf("Error: incorrect number of parameters for alias command.\n");}

}

else if(strcmp(tkarray[0], "unalias") == 0){//removes alias

	if(nt == 2){
		unalias(nt);
		numAliases--;
		}
	else{
		printf("Error: incorrect number of parameters for the unalias command.\n");}

}


	else{
		fork_command();
		}

}


void newCmd(char* inputcmd) { //This function adds the new command to the history list

		strcpy(history[cmdcount%historySize], inputcmd);
		writeToFile(".hist_list.txt", strcpy(history[cmdcount%historySize], inputcmd));
		cmdcount++;

 }

void listHistory(){ //this function calls and displays the history

	if(cmdcount<20){ //this if statement displays the history without empty slots if <20 commands
		for(int i = 0, j = 1; i < cmdcount%(historySize) ; i++, j++)
       		printf("%d.%s \n", (j), history[i]);
	}
	else{ //this is used to correctly display the circular array
		int number = 1;
		int i=cmdcount%historySize;
		do{
			if (history[i]) {
				printf("%d: %s\n", (number), history[i]);
				number++;
			}
			i = (i+1)%historySize;		//increments i++ in the circular array
		}while (i!=cmdcount%historySize);	//then loops to the beginning before 								returning to cmdcount
	}

}


void fork_command(){

pid_t pid;

pid = fork();

if(pid < 0) {
	fprintf(stderr, "Fork Failed");
}

else if(pid == 0){
	execvp(tkarray[0], tkarray);
	perror("Error");
	exit(EXIT_FAILURE);
}

else if(pid > 0){
	wait(NULL);

}

}

void setAlias(int noTokens){

int amount = numAliases;

//checks if there are any aliases already using the name given
for(int i = 0; i < amount; i++){
	if(strcmp(aliases[i].name, tkarray[1]) == 0){
		amount = i;
		numAliases--;	
		printf("alias %s -> ", aliases[i].name);
		for(int i = 0; i <  aliases[amount].parameters; i++){ 
			printf("%s ", aliases[amount].command[i]);}
		printf(" will be overrided.\n");
	}

}


if(numAliases < 10){//ensures we don't have more than ten aliases stored
	strcpy(aliases[amount].name, tkarray[1]);
	aliases[amount].parameters = noTokens-2;
	printf("new alias: %s -> ", aliases[amount].name);
	for(int i = 0; i <  aliases[amount].parameters; i++){ //copies all parameters of the aliased command
		strcpy(aliases[amount].command[i], tkarray[i+2]);
		printf("%s ", aliases[amount].command[i]);}
	printf("\n");
}

else{ 	printf("Maximum number of aliases has been reached. unable to add alias.\n");
	numAliases--;}

}

void printAliases(){

int amount = numAliases;

if(amount == 0)
	printf("There are currently no saved aliases\n");

else 
	printf("The current saved aliases are: \n");
	
	for(int i = 0; i < amount; i++){
		printf("alias %d: ", i+1);
		printf("%s -> ", aliases[i].name);
		for(int j = 0; j < aliases[i].parameters; j++){
			printf("%s ", aliases[i].command[j]);}
		printf("\n");
	}
}

int checkAlias(){

int addedTokens = 0;

for(int i = 0; i < numAliases; i++){
	if(strcmp(tkarray[0], aliases[i].name)==0){
		for(int j = 0; j < aliases[i].parameters; j++){
			tkarray[j] = aliases[i].command[j];
			addedTokens++;
		}
	}
}

return addedTokens; //for adjusting nt variable

}


void unalias(int noTokens){

bool found = false;
int amount = numAliases;
int foundAt = 0;

for(int i = 0; i < amount; i++){
		if(strcmp(aliases[i].name, tkarray[1]) == 0){
			foundAt = i;
			found = true;	
		}

}
if(found == true){	
	for(int i = foundAt; i < amount-1; i++){
		strcpy(aliases[i].name, aliases[i+1].name);
		aliases[i].parameters = aliases[i+1].parameters;
			for(int k = 0; k < aliases[i].parameters; k++){
				strcpy(aliases[i].command[k], aliases[i+1].command[k]);
			}
    }
}

if(found == false){
	printf("Error: No such alias exists.\n");
	numAliases++;
}

else{ 
	strcpy(aliases[amount-1].name, "\0");
	aliases[amount-1].parameters = 0;
	for(int j = 0; j < aliases[amount-1].parameters; j++){
		strcpy(aliases[amount-1].command[j], "\0");

	}
	printf("alias successfully removed.\n");
}
}



void writeToFile(char* fileName, char* text)
{
   
   int num;
   FILE *fptr;
   char* currentHistory;
   fptr = fopen(fileName,"a");

   fprintf(fptr,"%s\n", text);
   fclose(fptr);


}

void readFile(char* fileName)
{
   
   int i = 0;
   char string[512];
   char* lines[20];

   FILE *fptr;
   fptr = fopen(fileName,"r");

   //checks if file exists then prints each line
   if(fptr){
	   while(fgets(string, 512, fptr) != NULL){

		   //printf("%d. %s", i, string);
		   strcpy(history[i%historySize], string);
		   i++;
		   cmdcount++;
		

	   }

		fclose(fptr);
   }


}
