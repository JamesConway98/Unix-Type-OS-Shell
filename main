#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h> 
#include <stdbool.h>

void shell_loop();
void getInput();
void tokeniser(char *);
void newCmd(char*);
void checkAlias();
void checkCommands(int);
int find_command(char []);
void fork_command();
void setpath(char []);
void getpath();
void writeToFile(char*, char*);
void readFile(char*);
void setAlias(int nt);
void printAliases();
void unalias();

void listHistory();


int running = 0;
char *tkarray[512];
int numAliases;

#define historySize 20	// The size of the history array
int cmdcount = 0;		// Keeps keeps track of the number of commands used
char history[historySize][512];	// Pointer to the history of commands used


typedef struct alias{
	char name[15];
	char command[15];
}alias;

struct alias aliases[10];

void main(){
    
    
	char *path = getenv("PATH"); /*saves original path*/
	chdir(getenv("HOME"));
	readFile(".hist_list.txt");// loads history from file
	shell_loop();
	setenv("PATH", path, 1); /*restores orignal path upon exit*/
	printf("%s \n", path);
}


void shell_loop(){

numAliases = 0;

    while(running == 0){
    	printf(":) ");
	    getInput();
    }   

}

void setpath(char *dir) {
	char *oldpath = getenv("PATH");
	setenv("PATH", dir, 1);
	char *path = getenv("PATH");
	if (strcmp(dir, path) == 0) {
		printf("%s \n", path);
	}
	else {
		printf("Re-pathing has failed, please try again");
		setenv("PATH", oldpath, 1);
	}
}

void getpath() {
	char *path = getenv("PATH");
	printf("%s \n", path);
}


void getInput(){

	char input[512];



	if(fgets(input, 512, stdin) == NULL) { //gets input AND exits if CTRL D is pressed
		printf("\n");
		running = 1;
		return;
	}

	input[strlen(input)-1] = '\0'; //adds null to end of input string
	tokeniser(input);
}	

void tokeniser(char *input){

		for(int i = 0; i<512; i++){
			tkarray[i] = '\0';
	}
	char inputcpy[512];
	char *token;
	int nt = 0; //number of tokens
	strcpy(inputcpy, input); //makes a copy of input



	token = strtok (input, " |><&;\t\n"); //creates the first token

	if (token == NULL){ //if input is enter key, returns to start of loop
		return;
	}

	while (token != NULL){	//tokenises rest of input
		tkarray[nt] = token;
			
		token = strtok (NULL, " |><&;\t\n");
		nt++;
	}
	tkarray[nt] = NULL; //sets the last token to null

	if(strcspn(tkarray[0], "!-") == 0){ //history invokation. MUST BE ABOVE CHECKCOMMANDS
		if(strcmp(tkarray[0], "!!") == 0 && nt == 1){

		strcpy(input, history[(cmdcount%historySize)-1]);

		}else if(strcmp(tkarray[0], "!-") == 0 && nt == 2){

		int histnum = atoi(tkarray[1]);	

		printf("%d\n", histnum);
		strcpy(input, history[(cmdcount%historySize)-1]);
		

		}
		else{
			//do a thing as well		
		}
	}else{
		newCmd(inputcpy);	//This adds the input to the history of commands
	}

    	checkAlias(); //changes letters in token array to aliases

	checkCommands(nt); //checks the input for list of commands

}
void checkCommands(int nt){
    
	if(strcmp(tkarray[0], "exit") == 0){ //closes the shell
		
		if(nt == 1){
			running = 1;
		}else{
			
			printf("Error: exit command doesn't take parameters\n");		

		}
	}
	

	else if(strcmp(tkarray[0], "cd") == 0){
		
		if(nt == 2){
			if (chdir(tkarray[1]) == 0) {
				printf("Changing dir\n");
			}else{
				perror("Error");

			}
		}else if(nt == 1){

			chdir(getenv("HOME"));

		}else{
			printf("Error: cd takes 1 argument\n");	
			
		}
		
	}

	else if (strcmp(tkarray[0], "getpath") == 0){
		if (nt == 1) {
			getpath();
		}
		else {
			printf("Getpath does not require any parameters, please try again \n");
		}
	}

	else if (strcmp(tkarray[0], "setpath") == 0){
		if (nt ==2) {
			setpath(tkarray[1]);
		}
		else if (nt != 2) {
			printf("Setpath requires one parameter, please try again. \n");
		}
	}
	


	
	else if(strcmp(tkarray[0], "history") == 0){ //Command displays history list
		
		if(nt == 1){ //takes one parameter
			listHistory();
		}else{
			
			printf("Error: History command doesn't take parameters\n");		

		}
	}
	
    else if(strcmp(tkarray[0], "alias") == 0){
	
		if(nt >= 3){
			if(numAliases <= 10){
		 setAlias(nt);
			numAliases++;}
			else printf("Maximum number of aliases has been reached. unable to add alias.\n");
			}

		else if(nt == 1){
		printAliases();}
		
		else{ 
			printf("Error: incorrect number of parameters for alias command.\n");}

}

else if(strcmp(tkarray[0], "unalias") == 0){

	if(nt == 2){
		unalias();
		numAliases--;
		}
	else{
		printf("Error: incorrect number of parameters for the unalias command.\n");}

}


	else{
		fork_command();
		}

}


void newCmd(char* inputcmd) { //This function adds the new command to the history list

		strcpy(history[cmdcount%historySize], inputcmd);
		writeToFile(".hist_list.txt", strcpy(history[cmdcount%historySize], inputcmd));
		cmdcount++;

 }

void listHistory(){ //this function calls and displays the history

	if(cmdcount<20){ //this if statement displays the history without empty slots if <20 commands
		for(int i = 0, j = 1; i < cmdcount%(historySize) ; i++, j++)
       		printf("%d.%s \n", (j), history[i]);
	}
	else{ //this is used to correctly display the circular array
		int number = 1;
		int i=cmdcount%historySize;
		do{
			if (history[i]) {
				printf("%d %s\n", (number), history[i]);
				number++;
			}
			i = (i+1)%historySize;		//increments i++ in the circular array
		}while (i!=cmdcount%historySize);	//then loops to the beginning before 								returning to cmdcount
	}

}


void fork_command(){

pid_t pid;

pid = fork();

if(pid < 0) {
	fprintf(stderr, "Fork Failed");
}

else if(pid == 0){
	execvp(tkarray[0], tkarray);
	perror("Error");
	exit(EXIT_FAILURE);
}

else if(pid > 0){
	wait(NULL);

}

}

void setAlias(int noTokens){

int amount = numAliases;


for(int i = 0; i < amount; i++){
	if(strcmp(aliases[i].command, tkarray[2]) == 0){
		amount = i;
		printf("alias '%s -> %s' has been overridden.\n", aliases[amount].name, aliases[amount].command);
		numAliases--;
		}
	}

if(numAliases < 10){
	strcpy(aliases[amount].name, tkarray[1]);
	strcpy(aliases[amount].command, tkarray[2]);
	printf("new alias: %s -> %s\n", aliases[amount].name, aliases[amount].command);
}

else{ 	printf("Maximum number of aliases has been reached. unable to add alias.\n");
	numAliases--;}

}

void printAliases(){

int amount = numAliases;

if(amount == 0)
	printf("There are currently no saved aliases\n");

else 
	printf("The current saved aliases are: \n");
	
	for(int i = 0; i < amount; i++){
		printf("alias %d :", i);
		printf("%s -> %s\n", aliases[i].name, aliases[i].command);
	}
}

void checkAlias(){

for(int i = 0; i < numAliases; i++){
	if(strcmp(aliases[i].name, tkarray[0]) == 0){
		strcpy(tkarray[0], aliases[i].command);}
}

}


void unalias(){

bool found = false;
int amount = numAliases;

	for(int i = 0; i < amount; i++){
		if(strcmp(aliases[i].command, tkarray[1]) == 0){
			for(int j = i; j <= amount-1; j++){
				strcpy(aliases[j].name, aliases[j+1].name);
				strcpy(aliases[j].command, aliases[j+1].command);
				found = true;
			}
			strcpy(aliases[amount-1].name, "\0");
			strcpy(aliases[amount-1].command, "\0");
			
		}
	}

if(found == false){
printf("Error: No such alias exists.\n");
}

}



void writeToFile(char* fileName, char* text)
{
   
   int num;
   FILE *fptr;
   char* currentHistory;
   fptr = fopen(fileName,"a");

   fprintf(fptr,"%s\n", text);
   fclose(fptr);


}

void readFile(char* fileName)
{
   
   int i = 0;
   char string[512];
   char* lines[20];

   FILE *fptr;
   fptr = fopen(fileName,"r");

   //checks if file exists then prints each line
   if(fptr){
	   while(fgets(string, 512, fptr) != NULL){

		   //printf("%d. %s", i, string);
		   strcpy(history[i%historySize], string);
		   i++;
		   cmdcount++;
		

	   }

		fclose(fptr);
   }


}

